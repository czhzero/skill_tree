# 多态的概念


“polymorphism(多态）”一词来自希腊语，意为“多种形式”。多数Java程序员把多态看作对象的一种能力，使其能调用正确的方法版本。尽管如此，这种面向实现的观点导致了多态的神奇功能，胜于仅仅把多态看成纯粹的概念。

Java中的多态总是子类型的多态。几乎是机械式产生了一些多态的行为，使我们不去考虑其中涉及的类型问题。本文研究了一种面向类型的对象观点，分 析了如何将对象能够 表现的行为和对象即将表现的行为分离开来。抛开Java中的多态都是来自继承的概念，我们仍然可以感到，Java中的接口是一组没有公共代码的对象共享实 现。


# 多态的好处

消除类型之间的耦合关系。

- 可替换性（substitutability）。
	
	多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。

- 可扩充性（extensibility）。

	多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。

- 接口性（interface-ability）。

	多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。

- 灵活性（flexibility）。

	它在应用中体现了灵活多样的操作，提高了使用效率。
	
- 简化性（simplicity）。

	多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。


# 多态的分类

- 广义多态分类
	- 强制的 
	- 重载的
	- 参数的
	- 包含的
- 狭义多态分类
	- 动态绑定
	
## 强制的多态

强制多态隐式的将参数按某种方法，转换成编译器认为正确的类型以避免错误。在以下的表达式中，编译器必须决定二元运算符‘+’所应做的工作：

```

2.0 + 2.0

2.0 + 2

2.0 + "2"

```

第一个表达式将两个double的 操作数相加；Java中特别声明了这种用法。

第二个表达式将double型和int相加。Java中没有明确定义这种运算。不过，编 译器隐式的将第二个操作数转换为double型，并作double型的加法。做对程序员来说十分方便，否则将会抛出一个编译错误，或者强制程序员显式的将 int转换为double。

第三个表达式将double与一个String相加。Java中同样没有定义这样的操作。所以，编译器将 double转换成String类型，并将他们做串联。

强制多态也会发生在方法调用中。

假设类A继承了类Base，类B有一个方法，原型为m(Base)，在下面的代码中，编译器隐式的将A类的对象a转化为Base类的对象。这种隐式的转换使 m(Base)方法使用所有能转换成Base类的所有参数。


```

public class Base {
}

public class A extends Base {

}

public class B {
	public void m(Base base) {
		//dosomething
	}
}

public class Client {
	B b = new B(); 
	A a = new A();  
   b.m(a); 
}



```


并且，隐式的强制转换，可以避免类型转换的麻烦，减少编译错误。当然，编译器仍然会优先验证符合定义的对象类型。

	

## 重载的多态

重载 允许用相同的运算符或方法，去表示截然不同的意义。‘+’在上面的程序中有两个意思：两个double型的数相加；两个串相连。另外还有整型相加，长整 型，等等。这些运算符的重载，依赖于编译器根据上下文做出的选择。以往的编译器会把操作数隐式转换为完全符合操作符的类型。虽然Java明确支持重载，但 不支持用户定义的操作符重载。

Java支持用户定义的函数重载。一个类中可以有相同名字的方法，这些方法可以有不同的意义。这些重载 的方法中，必须满足参数数目不同，相同位置上的参数类型不同。这些不同可以帮助编译器区分不同版本的方法。

编译器以这种唯一表示的特 征来表示不同的方法，比用名字表示更为有效。据此，所有的多态行为都能编译通过。

强制和重载的多态都被分类为特定的多态，因为这些多 态都是在特定的意义上的。这些被划入多态的特性给程序员带来了很大的方便。强制多态排除了麻烦的类型和编译错误。重载多态像一块糖，允许程序员用相同的名 字表示不同的方法，很方便。


## 参数的多态

参数多态允许把许多类型抽象成单一的表示。例如，List抽象类中，描述了一组具有同样特征的对象，提供了一个通用的模板。你可以通过指定一种类型以重用这个抽象类。这些参数可以是任何用户定义的类型，大量的用 户可以使用这个抽象类，因此参数多态毫无疑问的成为最强大的多态。

乍一看，上面抽象类好像是java.util.List的功能。然 而，Java实际上并不支持真正的安全类型风格的参数多态，这也是java.util.List和java.util的其他集合类是用原始的 java.lang.Object写的原因。Java的单根继承方式解决了部分问题，但没有发挥出参数多态的全部功能。


## 包含的多态

包含多态通过值的类型和集合的包含关系实现了多态的行为.在包括Java在内的众多面向对象语言中，包含关系是子类型的。所以，Java的包含多态是子 类型的多态。

在早期，Java开发者们所提及的多态就特指子类型的多态。通过一种面向类型的观点，我们可以看到子类型多态的强大功能。

更多关于广义分类多态的解释，请参看[java中实现多态的机制是什么?](http://blog.csdn.net/xiaoyu714543065/article/details/8130027)

## 动态绑定

动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。

JAVA虚拟机调用一个类方法时，它会基于对象引用的类型(通常在编译时可知)来选择所调用的方法。相反，当虚拟机调用一个实例方法时，它会基于对象实际 的类型(只能在运行时得知)来选择所调用的方法，这就是动态绑定，是多态的一种。动态绑定为解决实际的业务问题提供了很大的灵活性，是一种非常优美的机制。

 JAVA虚拟机规范并没有规定JAVA对象在堆里是如何表示的。对象的内部表示也影响着整个堆以及垃圾收集器的设计，它由虚拟机的实现者决定。

- JAVA对象模型
 
  JAVA对象中包含的基本数据由它所属的类及其所有超类声明的实例变量组成。只要有一个对象引用，虚拟机就必须能够快速地定位对象实例的数据。另外，它也 必须能通过该对象引用访问相应的类数据(存储于方法区的类型信息)，因此在对象中通常会有一个指向方法区的指针。当程序在运行时需要转换某个对象引用为另 外一种类型时，虚拟机必须要检查这种转换是否被允许，被转换的对象是否的确是被引用的对象或者它的超类型。当程序在执行instanceof操作时，虚拟 机也进行了同样的检查。所以虚拟机都需要查看被引用的对象的类数据。

  不管虚拟机的实现使用什么样的对象表示法，很可能每个对象都有一个方法表因为方法表加快了调用实例方法时的效率。但是JAVA虚拟机规范并未要求必须使用方法表，所以并不是所有实现中都会使用它。

  下面是一种JAVA对象的内存表示：
  
  ![](http://o7y1sf21i.bkt.clouddn.com/blog/8/binding1.png)

  方法数据存放在类的方法区中，包含一个方法的具体实现的字节码二进制。方法指针直接指向这个方法在内存中的起始位置，通过方法指针就可以找到这个方法。
  
- 动态绑定内部机制

方法表是一个指向方法区中的方法指针的数组。方法表中不包含static、private等静态绑定的方法，仅仅包含那些需要动态绑定的实例方法。

  在方法表中，来自超类的方法出现在来自子类的方法之前，并且排列方法指针的顺序和方法在class文件中出现的顺序相同，这种排列顺序的例外情况是，被子类的方法覆盖的方法出现在超类中该方法第一次出现的地方。


```
public class Base   
{  
  public Base()  
  {  
  }  
     
  public void test()  
  {  
    System.out.println( "int Base" );  
  }  
    
  public void print()  
  {  
  }  
}  
  
public class Derive extends Base  
{  
  public Derive()  
  {  
  }  
  
  public void test()  
  {  
    System.out.println( "int Derive" );  
  }  
    
  public void sayHello()  
  {  
  }  
    
  public static void main( String[] args )  
  {  
      Base base = new Derive();  
      base.test();  
  }  
}  

```

 上例中的Base和Derive的方法表如下：


  ![](http://o7y1sf21i.bkt.clouddn.com/blog/8/binding2.png)

  在这个例子里，test()方法在Base和Derive的方法表中都是同一个位置-位置1。在Base方法表中，test()指针是Base的test()方法内存地址；而在Derive方法表中，方法表的位置1放置的是Derive的test()方法内存地址。

  当JAVA虚拟机执行base.test()时，通过base引用可以找到base所指向的实际对象的内存位置，现在虚拟机不知道base引用的实际对象 是Base还是Derive。但是根据上面的对象内存模型，虚拟机从对象内存中的第一个指针“特殊结构指针”开始，可以找到实际对象的类型数据和 Class实例，这样虚拟机就可以知道base引用的实际对象是Derive对。为了执行test()，虚拟机需要找到test()的字节码，方法的字节 码存放在方法区中。虚拟机从对象内存中的第一个指针“特殊结构指针”开始，搜寻方法表的位置1，位置1指向的test()方法是Derive类的 test()方法，这就是JAVA虚拟机将要执行的test()的字节码。现在，虚拟机知道了调用的实际对象是Derive对象，调用的实际test() 方法是Derive类的test()方法，所以JAVA虚拟机能够正确执行-调用base引用的实际对象的方法而不是base引用本身的方法。

  这是动态绑定的一种实现方式，根据不同的JAVA虚拟机平台和不同的实际约束，动态绑定可以有不同的内部实现机制。

